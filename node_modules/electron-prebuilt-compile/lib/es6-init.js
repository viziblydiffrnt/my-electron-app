'use strict';

var _electron = require('electron');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _electronCompile = require('electron-compile');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findPackageJson(initScript) {
  if (initScript === '/' || initScript.match(/^[A-Za-z]:$/)) {
    throw new Error("Can't find package.json");
  }

  // Walk up the parent directories until we find package.json. Make sure that
  // we're not actually stumbling upon a parent npm package
  let ret = _path2.default.join(initScript, 'package.json');
  if (_fs2.default.statSyncNoException(ret) && !_path2.default.resolve(_path2.default.dirname(ret), '..').match(/[\\\/]node_modules$/i)) {
    return ret;
  }

  return findPackageJson(_path2.default.dirname(initScript));
}

/**
 * Some debugger environment reconstruct process argument and inject args ignoring original order,
 * extract to find out right path for init script.
 *
 */
function getInitScriptPath() {
  const rawArgv = process.argv.filter(x => x.indexOf(`--inspect=`) === -1 && x.indexOf(`--debug-brk`))[2];
  return _path2.default.resolve(rawArgv);
}

function main() {
  const initScript = getInitScriptPath();
  const packageJson = findPackageJson(initScript);
  const packageJsonData = JSON.parse(_fs2.default.readFileSync(packageJson, 'utf8'));

  _electron.app.setName(packageJsonData.productName || packageJsonData.name);
  _electron.app.setVersion(packageJsonData.version);

  // Reconstitute the original arguments
  const args = process.argv.slice(2);
  process.argv = [process.argv[0]].concat(args);

  //passthrough electron-compile command args if it's specified
  const parsedArgs = require('yargs').alias('c', 'cachedir').alias('s', 'sourcemapdir').argv;
  (0, _electronCompile.init)(_path2.default.dirname(packageJson), initScript, null, parsedArgs.c || null, parsedArgs.s || null);
}

main();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lczYtaW5pdC5qcyJdLCJuYW1lcyI6WyJmaW5kUGFja2FnZUpzb24iLCJpbml0U2NyaXB0IiwibWF0Y2giLCJFcnJvciIsInJldCIsImpvaW4iLCJzdGF0U3luY05vRXhjZXB0aW9uIiwicmVzb2x2ZSIsImRpcm5hbWUiLCJnZXRJbml0U2NyaXB0UGF0aCIsInJhd0FyZ3YiLCJwcm9jZXNzIiwiYXJndiIsImZpbHRlciIsIngiLCJpbmRleE9mIiwibWFpbiIsInBhY2thZ2VKc29uIiwicGFja2FnZUpzb25EYXRhIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwic2V0TmFtZSIsInByb2R1Y3ROYW1lIiwibmFtZSIsInNldFZlcnNpb24iLCJ2ZXJzaW9uIiwiYXJncyIsInNsaWNlIiwiY29uY2F0IiwicGFyc2VkQXJncyIsInJlcXVpcmUiLCJhbGlhcyIsImMiLCJzIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLFNBQVNBLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDO0FBQ25DLE1BQUlBLGVBQWUsR0FBZixJQUFzQkEsV0FBV0MsS0FBWCxDQUFpQixhQUFqQixDQUExQixFQUEyRDtBQUN6RCxVQUFNLElBQUlDLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUlDLE1BQU0sZUFBS0MsSUFBTCxDQUFVSixVQUFWLEVBQXNCLGNBQXRCLENBQVY7QUFDQSxNQUFJLGFBQUdLLG1CQUFILENBQXVCRixHQUF2QixLQUErQixDQUFDLGVBQUtHLE9BQUwsQ0FBYSxlQUFLQyxPQUFMLENBQWFKLEdBQWIsQ0FBYixFQUFnQyxJQUFoQyxFQUFzQ0YsS0FBdEMsQ0FBNEMsc0JBQTVDLENBQXBDLEVBQXlHO0FBQ3ZHLFdBQU9FLEdBQVA7QUFDRDs7QUFFRCxTQUFPSixnQkFBZ0IsZUFBS1EsT0FBTCxDQUFhUCxVQUFiLENBQWhCLENBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTUSxpQkFBVCxHQUE2QjtBQUMzQixRQUFNQyxVQUFVQyxRQUFRQyxJQUFSLENBQWFDLE1BQWIsQ0FBcUJDLENBQUQsSUFBT0EsRUFBRUMsT0FBRixDQUFXLFlBQVgsTUFBNEIsQ0FBQyxDQUE3QixJQUFrQ0QsRUFBRUMsT0FBRixDQUFXLGFBQVgsQ0FBN0QsRUFBdUYsQ0FBdkYsQ0FBaEI7QUFDQSxTQUFPLGVBQUtSLE9BQUwsQ0FBYUcsT0FBYixDQUFQO0FBQ0Q7O0FBRUQsU0FBU00sSUFBVCxHQUFnQjtBQUNkLFFBQU1mLGFBQWFRLG1CQUFuQjtBQUNBLFFBQU1RLGNBQWNqQixnQkFBZ0JDLFVBQWhCLENBQXBCO0FBQ0EsUUFBTWlCLGtCQUFrQkMsS0FBS0MsS0FBTCxDQUFXLGFBQUdDLFlBQUgsQ0FBZ0JKLFdBQWhCLEVBQTZCLE1BQTdCLENBQVgsQ0FBeEI7O0FBRUEsZ0JBQUlLLE9BQUosQ0FBWUosZ0JBQWdCSyxXQUFoQixJQUErQkwsZ0JBQWdCTSxJQUEzRDtBQUNBLGdCQUFJQyxVQUFKLENBQWVQLGdCQUFnQlEsT0FBL0I7O0FBRUE7QUFDQSxRQUFNQyxPQUFPaEIsUUFBUUMsSUFBUixDQUFhZ0IsS0FBYixDQUFtQixDQUFuQixDQUFiO0FBQ0FqQixVQUFRQyxJQUFSLEdBQWUsQ0FBQ0QsUUFBUUMsSUFBUixDQUFhLENBQWIsQ0FBRCxFQUFrQmlCLE1BQWxCLENBQXlCRixJQUF6QixDQUFmOztBQUVBO0FBQ0EsUUFBTUcsYUFBYUMsUUFBUSxPQUFSLEVBQWlCQyxLQUFqQixDQUF1QixHQUF2QixFQUE0QixVQUE1QixFQUF3Q0EsS0FBeEMsQ0FBOEMsR0FBOUMsRUFBbUQsY0FBbkQsRUFBbUVwQixJQUF0RjtBQUNBLDZCQUFLLGVBQUtKLE9BQUwsQ0FBYVMsV0FBYixDQUFMLEVBQWdDaEIsVUFBaEMsRUFBNEMsSUFBNUMsRUFBa0Q2QixXQUFXRyxDQUFYLElBQWdCLElBQWxFLEVBQXdFSCxXQUFXSSxDQUFYLElBQWdCLElBQXhGO0FBQ0Q7O0FBRURsQiIsImZpbGUiOiJlczYtaW5pdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7aW5pdH0gZnJvbSAnZWxlY3Ryb24tY29tcGlsZSc7XHJcblxyXG5mdW5jdGlvbiBmaW5kUGFja2FnZUpzb24oaW5pdFNjcmlwdCkge1xyXG4gIGlmIChpbml0U2NyaXB0ID09PSAnLycgfHwgaW5pdFNjcmlwdC5tYXRjaCgvXltBLVphLXpdOiQvKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBwYWNrYWdlLmpzb25cIik7XHJcbiAgfVxyXG5cclxuICAvLyBXYWxrIHVwIHRoZSBwYXJlbnQgZGlyZWN0b3JpZXMgdW50aWwgd2UgZmluZCBwYWNrYWdlLmpzb24uIE1ha2Ugc3VyZSB0aGF0XHJcbiAgLy8gd2UncmUgbm90IGFjdHVhbGx5IHN0dW1ibGluZyB1cG9uIGEgcGFyZW50IG5wbSBwYWNrYWdlXHJcbiAgbGV0IHJldCA9IHBhdGguam9pbihpbml0U2NyaXB0LCAncGFja2FnZS5qc29uJylcclxuICBpZiAoZnMuc3RhdFN5bmNOb0V4Y2VwdGlvbihyZXQpICYmICFwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHJldCksICcuLicpLm1hdGNoKC9bXFxcXFxcL11ub2RlX21vZHVsZXMkL2kpKSB7XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbmRQYWNrYWdlSnNvbihwYXRoLmRpcm5hbWUoaW5pdFNjcmlwdCkpO1xyXG59XHJcblxyXG4vKipcclxuICogU29tZSBkZWJ1Z2dlciBlbnZpcm9ubWVudCByZWNvbnN0cnVjdCBwcm9jZXNzIGFyZ3VtZW50IGFuZCBpbmplY3QgYXJncyBpZ25vcmluZyBvcmlnaW5hbCBvcmRlcixcclxuICogZXh0cmFjdCB0byBmaW5kIG91dCByaWdodCBwYXRoIGZvciBpbml0IHNjcmlwdC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGdldEluaXRTY3JpcHRQYXRoKCkge1xyXG4gIGNvbnN0IHJhd0FyZ3YgPSBwcm9jZXNzLmFyZ3YuZmlsdGVyKCh4KSA9PiB4LmluZGV4T2YoYC0taW5zcGVjdD1gKSA9PT0gLTEgJiYgeC5pbmRleE9mKGAtLWRlYnVnLWJya2ApKVsyXTtcclxuICByZXR1cm4gcGF0aC5yZXNvbHZlKHJhd0FyZ3YpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWluKCkge1xyXG4gIGNvbnN0IGluaXRTY3JpcHQgPSBnZXRJbml0U2NyaXB0UGF0aCgpO1xyXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gZmluZFBhY2thZ2VKc29uKGluaXRTY3JpcHQpO1xyXG4gIGNvbnN0IHBhY2thZ2VKc29uRGF0YSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VKc29uLCAndXRmOCcpKTtcclxuXHJcbiAgYXBwLnNldE5hbWUocGFja2FnZUpzb25EYXRhLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKc29uRGF0YS5uYW1lKTtcclxuICBhcHAuc2V0VmVyc2lvbihwYWNrYWdlSnNvbkRhdGEudmVyc2lvbik7XHJcblxyXG4gIC8vIFJlY29uc3RpdHV0ZSB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXHJcbiAgY29uc3QgYXJncyA9IHByb2Nlc3MuYXJndi5zbGljZSgyKTtcclxuICBwcm9jZXNzLmFyZ3YgPSBbcHJvY2Vzcy5hcmd2WzBdXS5jb25jYXQoYXJncyk7XHJcblxyXG4gIC8vcGFzc3Rocm91Z2ggZWxlY3Ryb24tY29tcGlsZSBjb21tYW5kIGFyZ3MgaWYgaXQncyBzcGVjaWZpZWRcclxuICBjb25zdCBwYXJzZWRBcmdzID0gcmVxdWlyZSgneWFyZ3MnKS5hbGlhcygnYycsICdjYWNoZWRpcicpLmFsaWFzKCdzJywgJ3NvdXJjZW1hcGRpcicpLmFyZ3Y7XHJcbiAgaW5pdChwYXRoLmRpcm5hbWUocGFja2FnZUpzb24pLCBpbml0U2NyaXB0LCBudWxsLCBwYXJzZWRBcmdzLmMgfHwgbnVsbCwgcGFyc2VkQXJncy5zIHx8IG51bGwpO1xyXG59XHJcblxyXG5tYWluKClcclxuIl19